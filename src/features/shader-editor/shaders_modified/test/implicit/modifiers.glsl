#ifndef IMPLICIT_MODIFIERS_GLSL
#define IMPLICIT_MODIFIERS_GLSL

// modifiers.glsl
// Generated by GLSL Reorganizer
// Functions: 11 functions

#include "types.glsl"

// Uniforms
uniform float u_bias;
uniform float u_drop_xy;
uniform float u_drop_yz;
uniform float u_drop_zx;
uniform float u_sdf_thickness;
uniform float u_size_x;
uniform float u_size_y;
uniform float u_size_z;


// From: modifiers.glsl:22
Implicit Abs(Implicit iImplicit) {
    return Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient);
}

// From: modifiers.glsl:32
vec3 Boundary(Implicit i) {
    return -i.Distance * i.Gradient;
}

// From: modifiers.glsl:62
Implicit Conditional(bool condition, Implicit shape1, Implicit shape2) {
    if(condition) {
        return shape1;
    } else {
        return shape2;
    }
}

// From: modifiers.glsl:42
Implicit Mod(Implicit iImplicit, Implicit iM) {
    return Implicit(mod(iImplicit.Distance, iM.Distance), iImplicit.Gradient);  // TODO: fix gradient
}

// From: modifiers.glsl:47
Implicit Mod(Implicit iImplicit, float iM) {
    return Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient);  // TODO: fix gradient
}

// From: modifiers.glsl:27
Implicit Negate(Implicit v) {
    return Implicit(-v.Distance, -v.Gradient);
}

// From: modifiers.glsl:37
Implicit Sampson(Implicit a) {
    return Multiply(1.0 / length(a.Gradient), a);
}

// From: modifiers.glsl:52
Implicit TriangleWaveEvenPositive(Implicit param, float period) {
    float halfPeriod = 0.5 * period;
    float wave = mod(param.Distance, period) - halfPeriod;
    float dist = halfPeriod - abs(wave);
    vec3 grad = -sign(wave) * param.Gradient;

    return Implicit(dist, grad);
}

// From: modifiers.glsl:71
Implicit Shell(Implicit iImplicit, float thickness, float bias) {
    thickness *= 0.5;
    return Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);
}

// From: modifiers.glsl:77
Implicit indexedLattice(vec3 p, int index, out Implicit solid) {
    vec3 size = vec3(u_size_x, u_size_y, u_size_z);
    vec3 drop = vec3(u_drop_xy, u_drop_yz, u_drop_zx);
    Implicit p_x = Implicit(p.x, DirX);
    Implicit p_y = Implicit(p.y, DirY);
    Implicit p_z = Implicit(p.z, DirZ);
    Implicit _lattice_000 = TPMS_Gyroid(p_x, p_y, p_z, size, drop);
    Implicit lattice = Subtract(_lattice_000, u_bias);
    solid = lattice;
    if(index == 0)
        return solid;
    Implicit inverse = Multiply(-1.0, lattice);
    if(index == 1)
        return inverse;
    Implicit _thin_000 = Abs(lattice);
    Implicit thin = Subtract(_thin_000, u_sdf_thickness * 0.5);
    if(index == 2)
        return thin;
    Implicit twin = Multiply(-1.0, thin);
    if(index == 3)
        return twin;
    return Sphere(p, vec3(0.0), 0.5);
}

// From: modifiers.glsl:102
Implicit scaledLattice(vec3 scaledP, int index, out Implicit scaledBase) {
    vec3 p = (scaledP - center) * 10.0;
    Implicit base;
    Implicit indexed = indexedLattice(p, index, base);
    scaledBase = Divide(base, 10.0);
    return Divide(indexed, 10.0);
}

#endif // IMPLICIT_MODIFIERS_GLSL
