#ifndef IMPLICIT_PRIMITIVES_GLSL
#define IMPLICIT_PRIMITIVES_GLSL

// primitives.glsl
// Generated by GLSL Reorganizer
// Functions: 17 functions

#include "types.glsl"
#include "operations.glsl"

// From: primitives.glsl:17
Implicit Circle(vec2 p, vec2 center, float iRadius) {
    vec2 centered = p - center;
    float len = length(centered);
    float length = len - iRadius;
    return Implicit(length, vec3(centered / len, 0.0));
}

// From: primitives.glsl:9
Implicit SphereNative(vec3 iP, vec3 iCenter, float iRadius) {
    vec3 centered = iP - iCenter;
    float length = length(centered);
    float dist = length - iRadius;
    return Implicit(dist, centered / length);
}

// From: complex.glsl:33
Implicit BoxCenter(vec3 iP, vec3 iCenter, vec3 iSize) {
    vec3 p = iP - iCenter;
    vec3 b = iSize * 0.5;

    vec3 d = abs(p) - b;
    float dist = length(max(d, vec3(0.))) + min(max(d.x, max(d.y, d.z)), 0.);

    vec3 grad = (d.x > d.y) && (d.x > d.z) ? vec3(1., 0., 0.) : (d.y > d.z ? vec3(0., 1., 0.) : vec3(0., 0., 1.));

    if(d.x > 0. || d.y > 0. || d.z > 0.) {
        d = max(d, 0.);
        grad = d / length(d);
    }

    grad *= sign(p);

    return Implicit(dist, grad);
}

// From: complex.glsl:53
Implicit BoxCenteredSharp(Implicit p_x, Implicit p_y, Implicit p_z, vec3 center, vec3 size) {
    Implicit _planes_000_x = Subtract(p_x, center.x);
    Implicit _planes_001_x = Abs(_planes_000_x);
    vec3 _planes_002 = size * 0.5;
    Implicit planes_x = Subtract(_planes_001_x, _planes_002.x);
    Implicit _planes_000_y = Subtract(p_y, center.y);
    Implicit _planes_001_y = Abs(_planes_000_y);
    Implicit planes_y = Subtract(_planes_001_y, _planes_002.y);
    Implicit _planes_000_z = Subtract(p_z, center.z);
    Implicit _planes_001_z = Abs(_planes_000_z);
    Implicit planes_z = Subtract(_planes_001_z, _planes_002.z);
    return IntersectSharp3(planes_x, planes_y, planes_z);
}

// From: complex.glsl:120
Implicit Plane(vec3 p, vec3 origin, vec3 normal) {
    vec3 grad = normalize(normal);
    float v = dot(p - origin, grad);
    return Implicit(v, grad);
}

// From: complex.glsl:115
Implicit Plane(vec2 p, vec2 origin, vec2 normal) {
    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0));
}

// From: complex.glsl:132
Implicit PlaneNative(vec3 p, vec3 origin, vec3 normal) {
    vec3 grad = normalize(normal);
    float v = dot(p - origin, grad);
    return Implicit(v, grad);
}

// From: complex.glsl:127
Implicit PlaneNative(vec2 p, vec2 origin, vec2 normal) {
    return PlaneNative(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0));
}

// From: complex.glsl:68
Implicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle) {
    vec2 centered = p - center;
    mat2 rot = Rotate2D(-angle);
    centered = rot * centered;

    vec2 b = size * 0.5;
    vec2 d = abs(centered) - b;
    float dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);

    vec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    if(d.x > 0. && d.y > 0.)
        grad = d / length(d);

    grad *= -sign(centered);

    return Implicit(dist, vec3(grad * rot, 0.0));
}

// From: complex.glsl:103
Implicit RectangleCenterRotatedExp(vec2 p, vec2 center, vec2 size, float angle) {
    vec2 centered = p - center;
    mat2 rot = Rotate2D(-angle);
    size = size * 0.5;

    Implicit xPlane = Subtract(Abs(Implicit(centered.x, vec3(1, 0, 0))), size.x);
    Implicit yPlane = Subtract(Abs(Implicit(centered.y, vec3(0, 1, 0))), size.y);

    return Add(xPlane, yPlane);
}

// From: complex.glsl:87
Implicit RectangleCentered(vec2 p, vec2 center, vec2 size) {
    vec2 centered = p - center;
    vec2 b = size * 0.5;
    vec2 d = abs(centered) - b;
    float dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);

    vec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    if(d.x > 0. && d.y > 0.)
        grad = d / length(d);

    grad *= -sign(centered);

    return Implicit(dist, vec3(grad, 0.0));
}

// From: complex.glsl:12
Implicit TPMS_Gyroid(Implicit p_x, Implicit p_y, Implicit p_z, vec3 period, vec3 drop) {
    vec3 frequency = 2.0 * PI / period;
    Implicit xyz_x = Multiply(p_x, frequency.x);
    Implicit xyz_y = Multiply(p_y, frequency.y);
    Implicit xyz_z = Multiply(p_z, frequency.z);
    Implicit _TPMS_Gyroid_003_x = Sin(xyz_x);
    Implicit _TPMS_Gyroid_004_x = Multiply(drop.x, _TPMS_Gyroid_003_x);
    Implicit _TPMS_Gyroid_003_y = Sin(xyz_y);
    Implicit _TPMS_Gyroid_004_y = Multiply(drop.y, _TPMS_Gyroid_003_y);
    Implicit _TPMS_Gyroid_003_z = Sin(xyz_z);
    Implicit _TPMS_Gyroid_004_z = Multiply(drop.z, _TPMS_Gyroid_003_z);
    Implicit _TPMS_Gyroid_005_x = Cos(xyz_y);
    Implicit _TPMS_Gyroid_005_y = Cos(xyz_z);
    Implicit _TPMS_Gyroid_005_z = Cos(xyz_x);
    Implicit _TPMS_Gyroid_006 = Dot(_TPMS_Gyroid_004_x, _TPMS_Gyroid_004_y, _TPMS_Gyroid_004_z, _TPMS_Gyroid_005_x, _TPMS_Gyroid_005_y, _TPMS_Gyroid_005_z);
    float _TPMS_Gyroid_007 = AddVec(period);
    Implicit _TPMS_Gyroid_008 = Multiply(_TPMS_Gyroid_006, _TPMS_Gyroid_007);
    return Divide(_TPMS_Gyroid_008, 18.0);
}

// From: complex.glsl:173
Implicit sdfGyroid(vec3 p, float scale, float thickness) {
    vec3 gp = p * scale;
    float gyroid = abs(dot(sin(gp), cos(gp.zxy))) / scale - thickness;
    vec3 grad = normalize(vec3(
        dot(cos(gp), cos(gp.zxy)) * cos(gp.x),
        dot(cos(gp), cos(gp.zxy)) * cos(gp.y),
        dot(cos(gp), cos(gp.zxy)) * cos(gp.z)
    ));
    return Implicit(gyroid, grad);
}

// From: complex.glsl:185
Implicit sdfWaves(vec3 p, float scale, float amplitude) {
    vec3 wp = p * scale;
    float waves = sin(wp.x) * sin(wp.y) * sin(wp.z) * amplitude;
    vec3 grad = amplitude * vec3(
        cos(wp.x) * sin(wp.y) * sin(wp.z),
        sin(wp.x) * cos(wp.y) * sin(wp.z),
        sin(wp.x) * sin(wp.y) * cos(wp.z)
    );
    return Implicit(waves, normalize(grad));
}

// From: complex.glsl:160
Implicit LineSegment(vec2 p, vec2 start, vec2 end) {
    vec2 span = end - start;
    float length = length(span);
    vec2 dir = span / length;

    Implicit plane = Abs(Plane(p, start, vec2(dir.y, -dir.x)));
    vec2 center = (start + end) * 0.5;
    Implicit bounds = Subtract(Abs(Plane(p, center, dir)), length * 0.5);

    return Max(plane, bounds);
}

// From: complex.glsl:139
Implicit Rectangle(vec2 p, vec2 min, vec2 max) {
    vec2 center = (min + max) * 0.5;
    vec2 size = max - min;
    return RectangleCentered(p, center, size);
}

// From: complex.glsl:146
Implicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle) {
    vec2 centered = p - center;
    mat2 rot = Rotate2D(-angle);
    size *= 0.5;

    Implicit x = Plane(centered, vec2(0.0), rot * vec2(-1.0, 0.0));
    Implicit y = Plane(centered, vec2(0.0), rot * vec2(0.0, -1.0));
    Implicit cornerA = Subtract(Max(x, y), size);
    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);

    return IntersectionEuclidean(cornerA, cornerB, 0.0);
}

#endif // IMPLICIT_PRIMITIVES_GLSL
