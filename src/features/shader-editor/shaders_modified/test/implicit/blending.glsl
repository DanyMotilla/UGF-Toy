#ifndef IMPLICIT_BLENDING_GLSL
#define IMPLICIT_BLENDING_GLSL

// blending.glsl
// Generated by GLSL Reorganizer
// Functions: 18 functions

#include "types.glsl"

// From: blending.glsl:153
Implicit IntersectSharp3(Implicit a, Implicit b, Implicit c) {
    Implicit _IntersectSharp3_000 = Max(a, b);
    return Max(_IntersectSharp3_000, c);
}

// From: blending.glsl:126
Implicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {
    float unusedBlendingRatio;
    return IntersectionEuclidean(a, b, radius, unusedBlendingRatio);
}

// From: blending.glsl:132
Implicit IntersectionEuclidean(Implicit a, Implicit b, float radius, out float blendingRatio) {

    Implicit maxab = Max(a, b);
    Implicit r = CreateImplicit(radius);

    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient);
    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient);

    Implicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));

    if(maxab.Distance <= 0.0) {
        op.Gradient = maxab.Gradient;
    }

    float sum = a.Distance + b.Distance;
    blendingRatio = (sum == 0.0) ? 0.5 : (0.5 + 0.5 * b.Distance / sum);

    return op;
}

// From: blending.glsl:114
Implicit IntersectionExponential(Implicit a, Implicit b, float radius) {
//    float res = exp2( -a/k ) + exp2( -b/k );
//    return -k*log2( res );

    a = Exp(Divide(a, radius));
    b = Exp(Divide(b, radius));
    Implicit res = Add(a, b);

    return Multiply(Log(res), radius);
}

// From: blending.glsl:44
Implicit UnionChamfer(Implicit iA, Implicit iB, float k) {
    float param;
    return UnionChamfer(iA, iB, k, param);
}

// From: blending.glsl:50
Implicit UnionChamfer(Implicit iA, Implicit iB, float k, out float param) {
    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);
    Implicit h2 = Multiply(h, 0.5);
    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));
    param = h2.Distance;
    param = iA.Distance < iB.Distance ? param : (1.0 - param);

    return result;
}

// From: blending.glsl:70
Implicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {
    Implicit zero = CreateImplicit(0.0);
    Implicit r = CreateImplicit(radius);
    Implicit ua = Max(Subtract(r, a), zero);
    Implicit ub = Max(Subtract(r, b), zero);
    Implicit uc = Max(Subtract(r, c), zero);

    Implicit abc = Min(a, Min(b, c));
    Implicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));

    if(abc.Distance > 0.0) {
        op.Gradient = abc.Gradient;
    }

    return op;
}

// From: blending.glsl:88
Implicit UnionEuclidean(Implicit a, Implicit b, float radius) {
    float unused;
    return UnionEuclidean(a, b, radius, unused);
}

// From: blending.glsl:94
Implicit UnionEuclidean(Implicit a, Implicit b, float radius, out float blendingRatio) {
    Implicit ab = Min(a, b);
    Implicit r = CreateImplicit(radius);

    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0));
    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0));

    Implicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));

    if(ab.Distance > 0.0) {
        op.Gradient = ab.Gradient;
    }

    float sum = a.Distance + b.Distance;
    blendingRatio = (sum == 0.0) ? 0.5 : (0.5 + 0.5 * b.Distance / sum);

    return op;
}

// From: blending.glsl:28
Implicit UnionRound(Implicit iA, Implicit iB, float k) {
    float param;
    return UnionRound(iA, iB, k, param);
}

// From: blending.glsl:34
Implicit UnionRound(Implicit iA, Implicit iB, float k, out float param) {
    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);
    Implicit h2 = Multiply(Multiply(h, h), 0.5);
    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));
    param = 0.5 + 0.5 * (iA.Distance - iB.Distance) / (iA.Distance + iB.Distance);

    return result;
}

// From: blending.glsl:61
Implicit UnionRvachev(Implicit iA, Implicit iB, float k) {
    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));
    //  float param = 0.5;
    //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));

    return result;
}

// From: blending.glsl:9
Implicit UnionSmoothMedial(Implicit a, Implicit b, float k) {
    float unused;
    return UnionSmoothMedial(a, b, k, unused);
}

// From: blending.glsl:15
Implicit UnionSmoothMedial(Implicit a, Implicit b, float k, out float blendingRatio) {
    float h = max(k - abs(a.Distance - b.Distance), 0.0);
    float m = 0.25 * h * h / k;
    float n = 0.5 * h / k;

    float dist = min(a.Distance, b.Distance) - m;
    blendingRatio = (a.Distance < b.Distance) ? n : 1.0 - n;
    vec3 grad = mix(a.Gradient, b.Gradient, blendingRatio);

    return Implicit(dist, grad);
}

// From: blending.glsl:173
Implicit IntersectionRvachev(Implicit iA, Implicit iB, float k) {
    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));
}

// From: blending.glsl:168
Implicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k) {
    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));
}

// From: blending.glsl:159
Implicit UnionSmooth(Implicit a, Implicit b, float k) {
    a.Distance -= k;
    b.Distance -= k;
    //   if (min(a.Distance, b.Distance) >= 0.)
    //       return (Min(a, b));
    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1. - dot(a.Gradient, b.Gradient))), k);
}

// From: blending.glsl:178
Implicit IntersectionSmooth(Implicit iA, Implicit iB, float k) {
    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));
}

#endif // IMPLICIT_BLENDING_GLSL
